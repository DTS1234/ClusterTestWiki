{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Cluster Test Wiki This documentation provides comprehensive information and guidance for the Cluster Probe and Probe Builder projects. These software packages are designed to facilitate testing of Kubernetes clusters in terms of scalability and performance. The primary objective of these projects is to create a software-based solution for testing typical cloud service use cases within the context of reCluster project, a self-aware cloud orchestration system. Through this documentation, you will gain insights into the functionalities, architecture, implementation, testing, API specifications, and user guide for both Cluster Probe and Probe Builder. Whether you are new to testing Kubernetes clusters or seeking to enhance your existing knowledge, this documentation will serve as a valuable resource to understand and utilize these tools effectively. Table of contents Overview Probe builder Cluster probe","title":"Welcome to Cluster Test Wiki"},{"location":"#welcome-to-cluster-test-wiki","text":"This documentation provides comprehensive information and guidance for the Cluster Probe and Probe Builder projects. These software packages are designed to facilitate testing of Kubernetes clusters in terms of scalability and performance. The primary objective of these projects is to create a software-based solution for testing typical cloud service use cases within the context of reCluster project, a self-aware cloud orchestration system. Through this documentation, you will gain insights into the functionalities, architecture, implementation, testing, API specifications, and user guide for both Cluster Probe and Probe Builder. Whether you are new to testing Kubernetes clusters or seeking to enhance your existing knowledge, this documentation will serve as a valuable resource to understand and utilize these tools effectively.","title":"Welcome to Cluster Test Wiki"},{"location":"#table-of-contents","text":"Overview Probe builder Cluster probe","title":"Table of contents"},{"location":"cluster-probe/api-sepcification/","text":"","title":"Api sepcification"},{"location":"cluster-probe/design/","text":"Design The design of Cluster Probe follows a straightforward approach where each feature is implemented as a separate service. These services can be injected as Spring beans into the Controller class, which acts as the REST API implementation. the use of dependency injection through Spring beans enhances code modularity and testability. By decoupling components and providing dependencies through injection, the design promotes flexibility and makes it easier to introduce changes or extend functionality without impacting other parts of the system. Error handling is handled by an ErrorHandler class, which returns the appropriate HTTP response entities with the correct status code and message. This class allows to provide a uniform approach to handling exceptions and generating meaningful error responses. This practice improves the overall readability of the tests that will allow to better analyze the errors. The design includes model classes, such as TestSpecification for stress-ng job specifications and FileOperationSpecification for file operations endpoints. For transactional database tests, there is a separate controller to manage these specific cases. Additionally, a class following the Repository pattern is responsible for saving and retrieving objects from the database. This provides a structured representation of the data being processed. This separation of data models helps to enforce data integrity and ensures consistent handling of inputs and outputs across the application. In summary, the Controller class receives requests along with the corresponding specification objects, which are then processed by the service layer to execute the required logic. Errors are handled by the ErrorHandler, and the transactional database tests have their own controller and a dedicated class for database operations.","title":"Design"},{"location":"cluster-probe/design/#design","text":"The design of Cluster Probe follows a straightforward approach where each feature is implemented as a separate service. These services can be injected as Spring beans into the Controller class, which acts as the REST API implementation. the use of dependency injection through Spring beans enhances code modularity and testability. By decoupling components and providing dependencies through injection, the design promotes flexibility and makes it easier to introduce changes or extend functionality without impacting other parts of the system. Error handling is handled by an ErrorHandler class, which returns the appropriate HTTP response entities with the correct status code and message. This class allows to provide a uniform approach to handling exceptions and generating meaningful error responses. This practice improves the overall readability of the tests that will allow to better analyze the errors. The design includes model classes, such as TestSpecification for stress-ng job specifications and FileOperationSpecification for file operations endpoints. For transactional database tests, there is a separate controller to manage these specific cases. Additionally, a class following the Repository pattern is responsible for saving and retrieving objects from the database. This provides a structured representation of the data being processed. This separation of data models helps to enforce data integrity and ensures consistent handling of inputs and outputs across the application. In summary, the Controller class receives requests along with the corresponding specification objects, which are then processed by the service layer to execute the required logic. Errors are handled by the ErrorHandler, and the transactional database tests have their own controller and a dedicated class for database operations.","title":"Design"},{"location":"cluster-probe/implementation/","text":"Introduction Cluster Probe is written in Java 17, and it uses the Spring Boot Framework. Each feature's code is stored in its own java package. All packages expose a service class that can be injected as a dependency to the Controller, the REST api web layer class. Any error that has occurred during the test is handled by the ErrorHandler class that specifies an appropriate message and returns the error response entity. File operations FileOperations service is using java standard development kit libraries to implement the creation, update and the deletion for files. Those operations are performed based on the data specified in FileSystemSpecification class object. there is only one public method implemented for the FileOperationsService all the files created will be stored under the projects directory in the 'test' folder, then the number of files will be created based on parameters specified in the specification object. Specification class If the fileContent parameter will be null or empty no write operations will be performed. After all the operations are performed files and the 'test' directory are deleted: Stress ng In order to implement the stress ng jobs invocation, TestService creates an appropiate stress ng job based on the TestSpecification parameters, not all parameters are required so mostly TestService class implements the logic for creating the job accurately. Specification class for each parameter in the specification there is an according mapping method in the service class that based on whether the parameter is correct or not it creates an appropriate part of the command. There is also an option for receiving a plain command as a string, if this one is available and the isCommand flag is set to true the rest of the parameters will be ignored. Whenever the durationInSeconds parameter will not be available there is a default 24 hours value set in the mapTestTimeCommand : Transactional","title":"Implementation"},{"location":"cluster-probe/implementation/#introduction","text":"Cluster Probe is written in Java 17, and it uses the Spring Boot Framework. Each feature's code is stored in its own java package. All packages expose a service class that can be injected as a dependency to the Controller, the REST api web layer class. Any error that has occurred during the test is handled by the ErrorHandler class that specifies an appropriate message and returns the error response entity.","title":"Introduction"},{"location":"cluster-probe/implementation/#file-operations","text":"FileOperations service is using java standard development kit libraries to implement the creation, update and the deletion for files. Those operations are performed based on the data specified in FileSystemSpecification class object. there is only one public method implemented for the FileOperationsService all the files created will be stored under the projects directory in the 'test' folder, then the number of files will be created based on parameters specified in the specification object. Specification class If the fileContent parameter will be null or empty no write operations will be performed. After all the operations are performed files and the 'test' directory are deleted:","title":"File operations"},{"location":"cluster-probe/implementation/#stress-ng","text":"In order to implement the stress ng jobs invocation, TestService creates an appropiate stress ng job based on the TestSpecification parameters, not all parameters are required so mostly TestService class implements the logic for creating the job accurately. Specification class for each parameter in the specification there is an according mapping method in the service class that based on whether the parameter is correct or not it creates an appropriate part of the command. There is also an option for receiving a plain command as a string, if this one is available and the isCommand flag is set to true the rest of the parameters will be ignored. Whenever the durationInSeconds parameter will not be available there is a default 24 hours value set in the mapTestTimeCommand :","title":"Stress ng"},{"location":"cluster-probe/implementation/#transactional","text":"","title":"Transactional"},{"location":"cluster-probe/requirements/","text":"Introduction As it was mentioned before Cluster Probe is meant to run on any container, however it's main goal is to be a load receiver for Kubernetes cluster especially for the reCluster architecture. In order to make the testing process most effective there are several functional and non-functional requirements that were identified, they also constitute the most important features of the Cluster Probe. Functional requirements The system shall produce workloads based on a defined and measurable load specifications The system shall be able to produce intense I/O operations. The system shall be able to produce long-lasting or time specified intensive cpu tasks. The system shall be able to produce multiple asynchronous computing tasks. The system shall be able to receive data through the HTTP protocol. Non-functional requirements The system shall be capable of handling a high volume of concurrent requests for each endpoint efficiently. The system shall handle errors gracefully and provide appropriate error messages to clients. The system API shall be well-documented and contain an intuitive interface, allowing users to understand and interact with the endpoints easily.","title":"Requirements"},{"location":"cluster-probe/requirements/#introduction","text":"As it was mentioned before Cluster Probe is meant to run on any container, however it's main goal is to be a load receiver for Kubernetes cluster especially for the reCluster architecture. In order to make the testing process most effective there are several functional and non-functional requirements that were identified, they also constitute the most important features of the Cluster Probe.","title":"Introduction"},{"location":"cluster-probe/requirements/#functional-requirements","text":"The system shall produce workloads based on a defined and measurable load specifications The system shall be able to produce intense I/O operations. The system shall be able to produce long-lasting or time specified intensive cpu tasks. The system shall be able to produce multiple asynchronous computing tasks. The system shall be able to receive data through the HTTP protocol.","title":"Functional requirements"},{"location":"cluster-probe/requirements/#non-functional-requirements","text":"The system shall be capable of handling a high volume of concurrent requests for each endpoint efficiently. The system shall handle errors gracefully and provide appropriate error messages to clients. The system API shall be well-documented and contain an intuitive interface, allowing users to understand and interact with the endpoints easily.","title":"Non-functional requirements"},{"location":"cluster-probe/testing/","text":"","title":"Testing"},{"location":"cluster-probe/user-guide/","text":"","title":"User guide"},{"location":"overview/introduction/","text":"Introduction Welcome to the documentation of Cluster Probe and Probe Builder. This documentation provides comprehensive information and guidance on the Cluster Probe and Probe Builder projects, which are software packages designed for testing scalability and performance in Kubernetes clusters. The main objective of these projects is to create a software-based solution for testing typical cloud service use cases within the context of the reCluster project, a self-aware cloud orchestration system. The reCluster architecture presents a sustainable approach to data centre operations, leveraging upcycled hardware and prioritizing resource reduction. It seeks to minimize the environmental impact associated with computing while still offering viable computing capabilities. The main goal of the both Cluster Probe and Probe Builder is to be deployed on the reCluster and truly verify the computational capabilities of the system. However, Cluster Probe and Probe Builder offer a robust and user-friendly solution for testing the capabilities and limits of all the Kubernetes clusters. They enable application developers, system administrators, and testers to assess the performance, resilience, and efficiency of their cluster deployments. Cluster Probe allows users to conduct thorough performance tests by simulating real-world scenarios and evaluating the cluster's response under various workloads. This tool provides valuable insights into the system's capacity, identifies bottlenecks, and assesses scalability potential. On the other hand, Probe Builder , complements Cluster Probe by providing a convenient way to create custom test cases and scenarios. It utilizes JMeter's Java API to generate and control the load based on the specified input parameters. This allows users to define specific test criteria and performance goals, enabling fine-grained control over the testing process. The documentation is structured to cover the requirements, architecture, implementation, testing methodologies, API specifications, and user guidance for both Cluster Probe and Probe Builder. Whether you are new to these projects or seeking advanced configuration options, this documentation serves as a comprehensive resource for effectively utilizing these testing tools. Requirements and Dependencies Both projects, Cluster Probe and Probe Builder, are developed using the Java programming language. Familiarity with containerization concepts and Docker is required. Additionally, code snippets and examples will incorporate Kubernetes concepts. To run the local examples, ensure you have the following dependencies installed: JDK 17 : Java Development Kit version 17. Docker : Containerization platform for building and managing containers. Minikube : Lightweight Kubernetes implementation for local testing and development. Git : Version control system for code repositories. Postman : API development and testing tool (recommended for testing the API endpoints). Please ensure that you have the appropriate versions of these dependencies installed and configured correctly before proceeding with the projects. Note: Although Probe Builder is based on JMeter, it is not necessary to have in-depth knowledge of JMeter to utilize its basic functionalities. However, it is required to have JMeter installed. You can download JMeter from the official JMeter download page . Additionally, a GitHub account is recommended to access the code repositories and version control features. By having the above dependencies set up properly, you will be ready to explore and utilize the features and functionalities of Cluster Probe and Probe Builder effectively. Key features Cluster Probe and Probe Builder are designed to provide a system for defining and executing test loads based on a set of common and identified use cases. These use cases encompass various scenarios such as long-lasting intense CPU operations, file system operations, JSON data payloads, and file uploads. Probe Builder offers a user-friendly interface that enables users to specify these use cases and generate JMeter test plans. These test plans are executed and loaded onto a designated Kubernetes (k8s) cluster. After the tests are performed, Probe Builder collects the data and generates reports in the form of plots and CSV files. These reports provide valuable insights into the performance of the tested cluster. Cluster Probe, on the other hand, functions as a container running within k8s pods. It implements a REST API service capable of receiving different use cases, as mentioned earlier. For instance, it can handle CPU load scenarios using stress-ng or perform file operations. The diagram below illustrates the overall architecture and interaction between the components. You can find more detailed information about both of the projects in the following sections probe-builder , cluster-probe","title":"Introduction"},{"location":"overview/introduction/#introduction","text":"Welcome to the documentation of Cluster Probe and Probe Builder. This documentation provides comprehensive information and guidance on the Cluster Probe and Probe Builder projects, which are software packages designed for testing scalability and performance in Kubernetes clusters. The main objective of these projects is to create a software-based solution for testing typical cloud service use cases within the context of the reCluster project, a self-aware cloud orchestration system. The reCluster architecture presents a sustainable approach to data centre operations, leveraging upcycled hardware and prioritizing resource reduction. It seeks to minimize the environmental impact associated with computing while still offering viable computing capabilities. The main goal of the both Cluster Probe and Probe Builder is to be deployed on the reCluster and truly verify the computational capabilities of the system. However, Cluster Probe and Probe Builder offer a robust and user-friendly solution for testing the capabilities and limits of all the Kubernetes clusters. They enable application developers, system administrators, and testers to assess the performance, resilience, and efficiency of their cluster deployments. Cluster Probe allows users to conduct thorough performance tests by simulating real-world scenarios and evaluating the cluster's response under various workloads. This tool provides valuable insights into the system's capacity, identifies bottlenecks, and assesses scalability potential. On the other hand, Probe Builder , complements Cluster Probe by providing a convenient way to create custom test cases and scenarios. It utilizes JMeter's Java API to generate and control the load based on the specified input parameters. This allows users to define specific test criteria and performance goals, enabling fine-grained control over the testing process. The documentation is structured to cover the requirements, architecture, implementation, testing methodologies, API specifications, and user guidance for both Cluster Probe and Probe Builder. Whether you are new to these projects or seeking advanced configuration options, this documentation serves as a comprehensive resource for effectively utilizing these testing tools.","title":"Introduction"},{"location":"overview/introduction/#requirements-and-dependencies","text":"Both projects, Cluster Probe and Probe Builder, are developed using the Java programming language. Familiarity with containerization concepts and Docker is required. Additionally, code snippets and examples will incorporate Kubernetes concepts. To run the local examples, ensure you have the following dependencies installed: JDK 17 : Java Development Kit version 17. Docker : Containerization platform for building and managing containers. Minikube : Lightweight Kubernetes implementation for local testing and development. Git : Version control system for code repositories. Postman : API development and testing tool (recommended for testing the API endpoints). Please ensure that you have the appropriate versions of these dependencies installed and configured correctly before proceeding with the projects. Note: Although Probe Builder is based on JMeter, it is not necessary to have in-depth knowledge of JMeter to utilize its basic functionalities. However, it is required to have JMeter installed. You can download JMeter from the official JMeter download page . Additionally, a GitHub account is recommended to access the code repositories and version control features. By having the above dependencies set up properly, you will be ready to explore and utilize the features and functionalities of Cluster Probe and Probe Builder effectively.","title":"Requirements and Dependencies"},{"location":"overview/introduction/#key-features","text":"Cluster Probe and Probe Builder are designed to provide a system for defining and executing test loads based on a set of common and identified use cases. These use cases encompass various scenarios such as long-lasting intense CPU operations, file system operations, JSON data payloads, and file uploads. Probe Builder offers a user-friendly interface that enables users to specify these use cases and generate JMeter test plans. These test plans are executed and loaded onto a designated Kubernetes (k8s) cluster. After the tests are performed, Probe Builder collects the data and generates reports in the form of plots and CSV files. These reports provide valuable insights into the performance of the tested cluster. Cluster Probe, on the other hand, functions as a container running within k8s pods. It implements a REST API service capable of receiving different use cases, as mentioned earlier. For instance, it can handle CPU load scenarios using stress-ng or perform file operations. The diagram below illustrates the overall architecture and interaction between the components. You can find more detailed information about both of the projects in the following sections probe-builder , cluster-probe","title":"Key features"},{"location":"probe-builder/api-specification/","text":"","title":"Api specification"},{"location":"probe-builder/architecture/","text":"","title":"Architecture"},{"location":"probe-builder/design/","text":"","title":"Design"},{"location":"probe-builder/implementation/","text":"","title":"Implementation"},{"location":"probe-builder/requirements/","text":"Probe builder","title":"Requirements"},{"location":"probe-builder/testing/","text":"","title":"Testing"},{"location":"probe-builder/user-guide/","text":"","title":"User guide"}]}